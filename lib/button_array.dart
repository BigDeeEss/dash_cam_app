//  Import dart and flutter packages.
import 'package:flutter/material.dart';

// Import project-specific files.
import 'package:dash_cam_app/animated_button.dart';
import 'package:dash_cam_app/app_settings.dart';
import 'package:dash_cam_app/button.dart';
import 'package:dash_cam_app/button_specs.dart';

class ButtonArray extends StatefulWidget {
  ButtonArray({
    this.animation,
    Key? key,
  }) : super(key: key);

  //  [animation] is used to animate the launch of buttons onto the screen.
  //  Whilst this animation ranges from 0.0 to 1.0, in this instance the
  //  range of values 0.0--0.5 is reserved for animating the page transition
  //  whilst the range 0.5--1.0 is used for animating the buttons.
  //  [animation] is nullable because DashCamApp calls BasePage(title: 'Home',).
  final Animation<double>? animation;

  @override
  _ButtonArrayState createState() => _ButtonArrayState();
}

class _ButtonArrayState extends State<ButtonArray> {
  //  [buttonSpecList] defines a list of buttonSpec items which
  //  ultimately define the buttons on each screen.
  static List<ButtonSpec> buttonSpecList = [
    settings,
    files,
    home,
  ];

  /// [getOffset]
  Offset getOffset(BuildContext context) {
    //  Get size of screen in pixels.
    final Size size = MediaQuery.of(context).size;

    // Get characteristic button dimension including padding in pixels.
    double buttonDim =
        AppSettings.buttonSize + 2.0 * AppSettings.buttonPaddingCrossAxis;

    //  Convert [buttonDim] to an Offset.
    //  [AppSettings.buttonAlignment] switches between left and right entrance.
    return Offset(-AppSettings.buttonAlignment.x * size.width / buttonDim, 0);
  }

  /// [getButtonStartTime] calculates the point in the animation at which
  /// th ith button starts its animation.
  double getButtonStartTime(int i) {
    return 0.5 + (i / (buttonSpecList.length + 1)) * 0.5;
  }

  /// [getButtonStopTime] calculates the point in the animation at which
  /// th ith button starts its animation.
  double getButtonStopTime(int i) {
    return 0.5 + ((i + 2) / (buttonSpecList.length + 1)) * 0.5;
    // return 0.5 + pow((i + 2) / (buttonSpecList.length + 1), 1.0 / 3.0) * 0.5;
  }

  //  [slidingButtonList] is a class method which outputs a list of
  //  widgets. The list contains either a static or sliding button.
  List<Widget> slidingButtonList(
    BuildContext context,
    Animation<double>? animation,
    List<ButtonSpec> buttonSpecList,
  ) {
    //  Initialise [widgetList] ready for population.
    List<Widget> widgetList = [];

    //  Loop over [buttonSpecList] and convert each item in list to either a
    //  static button (if animation is null) or a SlideTransition with
    //  button for its child (if not).
    for (int i = 0; i < buttonSpecList.length; i++) {
      if (animation == null) {
        //  If animation is null then add static button to widgetList.
        widgetList.add(Button(buttonSpec: buttonSpecList[i]));
      } else {
        //  If animation is not null then add SlidingTransition to widgetList.
        widgetList.add(
          SlideTransition(
            position: Tween<Offset>(
              begin: getOffset(context),
              end: Offset.zero,
            ).animate(
              CurvedAnimation(
                //  Staggered button movement.
                curve: Interval(
                  getButtonStartTime(i),
                  getButtonStopTime(i),
                  curve: Curves.easeOutCubic,
                ),
                parent: animation,
              ),
            ),
            // child: Button(
            //   buttonSpec: buttonSpecList[i],
            // ),
            child: AnimatedButton(
              skewFactor: Tween<double>(
                begin: -0.3,
                end: 0.0,
              ).animate(
                CurvedAnimation(
                  //  Staggered button movement.
                  curve: Interval(
                    getButtonStartTime(i),
                    getButtonStopTime(i),
                    curve: Curves.easeOutCubic,
                  ),
                  parent: animation,
                ),
              ),
              buttonSpec: buttonSpecList[i],
            ),
          ),
        );
      }
    };
    return widgetList;
  }

  @override
  Widget build(BuildContext context) {
    //  Use a Container-Align-Column construct to position items in the list
    //  generated by [slidingButtonList].
    return Container(
      //  Request that this container expands to fit the entire screen.
      constraints: BoxConstraints.expand(
        width: double.infinity,
        height: double.infinity,
      ),

      //  Position the button array according to Align specs.
      //  Specs provided by AppSettings.
      child: Align(
        alignment: AppSettings.buttonAlignment,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          verticalDirection: (AppSettings.buttonAlignment.y < 0)
              ? VerticalDirection.down
              : VerticalDirection.up,
          children: slidingButtonList(
            context,
            widget.animation,
            buttonSpecList,
          ),
        ),
      ),
    );
  }
}
